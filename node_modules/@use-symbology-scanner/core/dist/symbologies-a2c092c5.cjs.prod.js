'use strict';

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

function encodeKey(key) {
  switch (key) {
    case 'Enter':
      return '\n';
    case 'Tab':
      return '\t';
    case 'Spacebar':
      return ' ';
    default:
      return key;
  }
}
function isCharacterClass(value) {
  const source = value instanceof RegExp ? value.source : value;
  if (source.startsWith('[') && source.endsWith(']') && source.length > 2) return true;
  return false;
}

class Symbology {
  constructor({
    name,
    allowedCharacters,
    minLength = 1,
    maxLength
  }) {
    this.name = name;
    this.minLength = minLength;
    if (maxLength && maxLength < minLength) throw new Error('maxLength must be greater than or equal to minLength');
    this.maxLength = maxLength;
    if (!isCharacterClass(allowedCharacters)) throw new Error('allowedCharacters must be a character class');
    const pattern = allowedCharacters instanceof RegExp ? allowedCharacters.source : allowedCharacters;
    this.allowedCharacters = new RegExp(pattern);
  }
  get symbolPattern() {
    var _this$maxLength;
    return new RegExp(`^${this.allowedCharacters.source}{${this.minLength},${(_this$maxLength = this.maxLength) !== null && _this$maxLength !== void 0 ? _this$maxLength : ''}}$`);
  }
  get characterPattern() {
    return new RegExp(`^${this.allowedCharacters.source}$`);
  }
  testCharacter(value) {
    return this.characterPattern.test(value);
  }
  testSymbol(value) {
    return this.symbolPattern.test(value);
  }
}

const STANDARD_SYMBOLOGY_KEYS = ['UPC-A', 'UPC-E', 'EAN 8', 'EAN 13', 'Codabar', 'Code 11', 'Code 39', 'Code 93', 'Code 128', 'Code 25 Interleaved', 'Code 25 Industrial', 'MSI Code', 'QR Code', 'PDF417', 'Data Matrix', 'Aztec Code', 'Dot Code'];
const STANDARD_SYMBOLOGY_OPTIONS = {
  'UPC-A': {
    allowedCharacters: /[\d]/,
    minLength: 12,
    maxLength: 12
  },
  'UPC-E': {
    allowedCharacters: /[\d]/,
    minLength: 8,
    maxLength: 8
  },
  'EAN 8': {
    allowedCharacters: /[\d]/,
    minLength: 8,
    maxLength: 8
  },
  'EAN 13': {
    allowedCharacters: /[\d]/,
    minLength: 13,
    maxLength: 13
  },
  'Codabar': {
    allowedCharacters: /[\d\-\$\:\/\.\+]/
  },
  'Code 11': {
    allowedCharacters: /[\d\-]/
  },
  'Code 39': {
    allowedCharacters: /[\dA-Z\ \-\.\$\/\+\%]/
  },
  'Code 93': {
    allowedCharacters: /[\dA-Z\ \-\.\$\/\+\%]/
  },
  'Code 128': {
    allowedCharacters: /[ -~]/
  },
  'Code 25 Interleaved': {
    allowedCharacters: /[\d]/
  },
  'Code 25 Industrial': {
    allowedCharacters: /[\d]/
  },
  'MSI Code': {
    allowedCharacters: /[\d]/
  },
  'QR Code': {
    allowedCharacters: /[\x00-\x7F]/
  },
  'PDF417': {
    allowedCharacters: /[\x00-\x7F]/
  },
  'Data Matrix': {
    allowedCharacters: /[\x00-\x7F]/
  },
  'Aztec Code': {
    allowedCharacters: /[\x00-\x7F]/
  },
  'Dot Code': {
    allowedCharacters: /[\x00-\xFF]/
  }
};
const STANDARD_SYMBOLOGIES = Object.fromEntries(Object.entries(STANDARD_SYMBOLOGY_OPTIONS).map(([key, options]) => [key, new Symbology(_objectSpread2({
  name: key
}, options))]));

exports.STANDARD_SYMBOLOGIES = STANDARD_SYMBOLOGIES;
exports.STANDARD_SYMBOLOGY_KEYS = STANDARD_SYMBOLOGY_KEYS;
exports.Symbology = Symbology;
exports._defineProperty = _defineProperty;
exports.encodeKey = encodeKey;
