'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var symbologies_dist_useSymbologyScannerCoreSymbologies = require('./symbologies-b8ce19ce.cjs.dev.js');

const DEFAULT_PREFIX = '';
const DEFAULT_SUFFIX = '';
const DEFAULT_MAX_DELAY = 20;
const configResolver = {
  target(value) {
    if (value) {
      return () => 'current' in value ? value.current : value;
    } else if (window) {
      return () => window.document;
    } else {
      return undefined;
    }
  },
  symbologies(value = [...symbologies_dist_useSymbologyScannerCoreSymbologies.STANDARD_SYMBOLOGY_KEYS]) {
    return value.map(v => {
      if (typeof v === 'string') {
        return symbologies_dist_useSymbologyScannerCoreSymbologies.STANDARD_SYMBOLOGIES[v];
      } else {
        return v;
      }
    });
  },
  enabled(value = true) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  preventDefault(value = false) {
    return value;
  },
  ignoreRepeats(value = true) {
    return value;
  },
  scannerOptions({
    prefix = DEFAULT_PREFIX,
    suffix = DEFAULT_SUFFIX,
    maxDelay = DEFAULT_MAX_DELAY
  } = {}) {
    return {
      prefix,
      suffix,
      maxDelay
    };
  }
};
function resolveWith(config = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    result[key] = resolver.call(result, config[key], key, config);
  }
  return result;
}

class Controller {
  constructor(config = {}, handler) {
    symbologies_dist_useSymbologyScannerCoreSymbologies._defineProperty(this, "sequence", '');
    symbologies_dist_useSymbologyScannerCoreSymbologies._defineProperty(this, "config", {});
    this.applyConfig(config);
    handler && this.applyHandler(handler);
  }
  addToSequence(event) {
    if (event.shiftKey && event.key === 'Shift') return;
    if (event.ctrlKey && event.key === 'Control') return;
    if (event.altKey && event.key === 'Alt') return;
    if (event.metaKey && event.key === 'Meta') return;
    const character = symbologies_dist_useSymbologyScannerCoreSymbologies.encodeKey(event.key);
    const matchesOneSymbology = this.config.symbologies.some(symbology => symbology.testCharacter(character));
    const matchesPrefix = character === this.config.scannerOptions.prefix;
    const matchesSuffix = character === this.config.scannerOptions.suffix;
    if (matchesOneSymbology || matchesPrefix || matchesSuffix) {
      this.sequence += character;
      if (matchesSuffix) {
        clearTimeout(this.timeout);
        this.evaluateSequence();
        this.resetSequence();
        return true;
      }
    } else {
      this.resetSequence();
      return true;
    }
  }
  evaluateSequence() {
    const {
      prefix,
      suffix
    } = this.config.scannerOptions;
    const isValid = this.sequence.startsWith(prefix) && this.sequence.endsWith(suffix);
    if (!isValid) return;
    const symbol = this.sequence.slice(prefix.length, suffix.length ? -1 * suffix.length : undefined);
    const symbologies = this.config.symbologies.flatMap(symbology => {
      const isMatch = symbology.testSymbol(symbol);
      return isMatch ? [symbology.name] : [];
    });
    if (symbologies.length && this.handler) {
      this.handler(symbol, symbologies);
    }
  }
  resetSequence() {
    this.sequence = '';
  }
  keyDown(event) {
    clearTimeout(this.timeout);
    const {
      config
    } = this;
    if (config.preventDefault) {
      event.preventDefault();
    }
    if (config.ignoreRepeats && event.repeat) {
      this.resetSequence();
    } else {
      const isReset = this.addToSequence(event);
      if (!isReset) {
        this.timeout = setTimeout(() => {
          this.evaluateSequence();
          this.resetSequence();
        }, config.scannerOptions.maxDelay);
      }
    }
  }
  applyHandler(handler) {
    this.handler = handler;
  }
  applyConfig(config) {
    this.config = resolveWith(config, configResolver);
  }
  bind() {
    let target;
    if (this.config.target) {
      target = this.config.target();
    }
    if (this.config.enabled && target) {
      target.addEventListener('keydown', this.keyDown.bind(this), this.config.eventOptions);
      const remove = () => {
        target.removeEventListener('keydown', this.keyDown.bind(this), this.config.eventOptions);
        this.listener = undefined;
      };
      this.listener = remove;
      return remove;
    }
  }
  effect() {
    this.bind();
    return this.clean();
  }
  clean() {
    if (this.listener) this.listener();
    this.listener = undefined;
    clearTimeout(this.timeout);
    this.timeout = undefined;
  }
}

exports.Symbology = symbologies_dist_useSymbologyScannerCoreSymbologies.Symbology;
exports.Controller = Controller;
