import { useRef as s, useCallback as h, useEffect as g } from "react";
var l = /* @__PURE__ */ ((e) => (e.Mouse = "mouse", e.Touch = "touch", e.Pointer = "pointer", e))(l || {}), d = /* @__PURE__ */ ((e) => (e.CancelledByMovement = "cancelled-by-movement", e.CancelledByRelease = "cancelled-by-release", e.CancelledOutsideElement = "cancelled-outside-element", e))(d || {});
const A = () => typeof window == "object" ? window?.PointerEvent ?? null : null, z = () => typeof window == "object" ? window?.TouchEvent ?? null : null;
function U(e) {
  const { nativeEvent: t } = e, u = z();
  return u && t instanceof u || "touches" in e;
}
function X(e) {
  const t = A();
  return e.nativeEvent instanceof MouseEvent && !(t && e.nativeEvent instanceof t);
}
function Y(e) {
  const { nativeEvent: t } = e;
  if (!t)
    return !1;
  const u = A();
  return u && t instanceof u || "pointerId" in t;
}
function R(e) {
  return X(e) || U(e) || Y(e);
}
function j(e) {
  return U(e) ? {
    x: e.touches[0].pageX,
    y: e.touches[0].pageY
  } : X(e) || Y(e) ? {
    x: e.pageX,
    y: e.pageY
  } : null;
}
function G(e) {
  return {
    target: e.target,
    currentTarget: e.currentTarget,
    nativeEvent: e,
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    persist: () => {
    }
  };
}
function J(e, {
  threshold: t = 400,
  captureEvent: u = !1,
  detect: y = l.Pointer,
  cancelOnMovement: w = !1,
  cancelOutsideElement: v = !0,
  filterEvents: p,
  onStart: M,
  onMove: C,
  onFinish: L,
  onCancel: b
} = {}) {
  const P = s(!1), c = s(!1), I = s(), a = s(), T = s(e), f = s(null), E = h(
    (n) => (r) => {
      c.current || R(r) && (p !== void 0 && !p(r) || (u && r.persist(), M?.(r, { context: n }), f.current = j(r), c.current = !0, I.current = r.currentTarget, a.current = setTimeout(() => {
        T.current && (T.current(r, { context: n }), P.current = !0);
      }, t)));
    },
    [u, p, M, t]
  ), i = h(
    (n) => (r, o) => {
      R(r) && c.current && (f.current = null, u && r.persist(), P.current ? L?.(r, { context: n }) : c.current && b?.(r, { context: n, reason: o ?? d.CancelledByRelease }), P.current = !1, c.current = !1, a.current !== void 0 && clearTimeout(a.current));
    },
    [u, L, b]
  ), m = h(
    (n) => (r) => {
      if (C?.(r, { context: n }), w !== !1 && f.current) {
        const o = j(r);
        if (o) {
          const B = w === !0 ? 25 : w, D = {
            x: Math.abs(o.x - f.current.x),
            y: Math.abs(o.y - f.current.y)
          };
          (D.x > B || D.y > B) && i(n)(r, d.CancelledByMovement);
        }
      }
    },
    [i, w, C]
  ), q = h(
    (n) => {
      if (e === null)
        return {};
      switch (y) {
        case l.Mouse: {
          const r = {
            onMouseDown: E(n),
            onMouseMove: m(n),
            onMouseUp: i(n)
          };
          return v && (r.onMouseLeave = (o) => {
            i(n)(o, d.CancelledOutsideElement);
          }), r;
        }
        case l.Touch:
          return {
            onTouchStart: E(n),
            onTouchMove: m(n),
            onTouchEnd: i(n)
          };
        case l.Pointer: {
          const r = {
            onPointerDown: E(n),
            onPointerMove: m(n),
            onPointerUp: i(n)
          };
          return v && (r.onPointerLeave = (o) => i(n)(o, d.CancelledOutsideElement)), r;
        }
      }
    },
    [e, i, v, y, m, E]
  );
  return g(() => {
    if (!window)
      return;
    function n(r) {
      const o = G(r);
      i()(o);
    }
    return window.addEventListener("mouseup", n), window.addEventListener("touchend", n), window.addEventListener("pointerup", n), () => {
      window.removeEventListener("mouseup", n), window.removeEventListener("touchend", n), window.removeEventListener("pointerup", n);
    };
  }, [i]), g(
    () => () => {
      a.current !== void 0 && clearTimeout(a.current);
    },
    []
  ), g(() => {
    T.current = e;
  }, [e]), q;
}
export {
  d as LongPressCallbackReason,
  l as LongPressEventType,
  J as useLongPress
};
